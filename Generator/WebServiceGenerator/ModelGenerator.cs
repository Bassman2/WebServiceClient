using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading;
using System.Xml.Linq;

namespace WebServiceGenerator
{
    [Generator]
    public class ModelGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider.CreateSyntaxProvider(
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node
                    ).Where(m => m is not null);

            var compilation = context.CompilationProvider.Combine(provider.Collect());

            context.RegisterSourceOutput(compilation, Excecute);





            ////SyntaxValueProvider syntaxProvider = ((IncrementalGeneratorInitializationContext)(ref context)).SyntaxProvider;
            ////IncrementalValuesProvider<TypeInfo> val = IncrementalValueProviderExtensions.Where<TypeInfo>(((SyntaxValueProvider)(ref syntaxProvider)).CreateSyntaxProvider<TypeInfo>((Func<SyntaxNode, CancellationToken, bool>)((SyntaxNode s, CancellationToken _) => (s is ClassDeclarationSyntax || s is RecordDeclarationSyntax) && HasEntityMaskAttributes((TypeDeclarationSyntax)(object)((s is TypeDeclarationSyntax) ? s : null))), (Func<GeneratorSyntaxContext, CancellationToken, TypeInfo>)((GeneratorSyntaxContext ctx, CancellationToken _) => GetTypeWithAttributes(ctx))), (Func<TypeInfo, bool>)((TypeInfo m) => m != null));
            //IncrementalValueProvider<(Compilation, ImmutableArray<TypeInfo>)> val2 = IncrementalValueProviderExtensions.Combine<Compilation, ImmutableArray<TypeInfo>>(((IncrementalGeneratorInitializationContext)(ref context)).CompilationProvider, IncrementalValueProviderExtensions.Collect<TypeInfo>(val));
            //context.RegisterSourceOutput<(Compilation, ImmutableArray<TypeInfo>)>(val2, (Action<SourceProductionContext, (Compilation, ImmutableArray<TypeInfo>)>)delegate (SourceProductionContext spc, (Compilation Left, ImmutableArray<TypeInfo> Right) source)
            //{
            //    //IL_000c: Unknown result type (might be due to invalid IL or missing references)
            //    Execute(source.Left, source.Right, spc);
            //});
        }

        private void Excecute(SourceProductionContext context, (Compilation Left, ImmutableArray<ClassDeclarationSyntax> Right) tuple)
        {
            var (compilation, classes) = tuple;

            if (classes.IsDefaultOrEmpty)
            {
                return;
            }

            StringBuilder sb = new();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine();
            sb.AppendLine("namespace Test;");
            sb.AppendLine();

            Debug(sb, tuple);


            foreach (var cla in classes.Where(c => HasAttributeWithNameAndNamespace(compilation, c, "WebServiceClient.Attributes.ModelAttribute")))
            {
                //var symbol = compilation.GetSemanticModel(cla.SyntaxTree).GetDeclaredSymbol(cla) as INamedTypeSymbol;
                var symbol = GetSymbol(compilation, cla);


                //DebugClass(sb, symbol!);
                //DebugProperties(sb, symbol!);
                //DebugAttributes(sb, symbol!);


                var classNamespace = symbol!.ContainingNamespace?.ToDisplayString();
                var classNameWithNamespace = symbol.ToDisplayString();
                var className = symbol.Name;

                //foreach (var attr in symbol.GetAttributes())
                //{
                //    var attrName = attr.AttributeClass?.Name;
                //    var attrNamespace = attr.AttributeClass?.ContainingNamespace?.ToDisplayString();
                //    var attrFullName = attr.AttributeClass?.ToDisplayString();

                //    sb.AppendLine($"// Attribute 123: {attrName} - {attrNamespace} - {attrFullName}");

                //    if (attr.ConstructorArguments.Length > 0)
                //    {
                //        sb.AppendLine($"//  +++++++ Has constructor arguments");
                //        foreach (var arg in attr.ConstructorArguments)
                //        {
                //            sb.AppendLine($"// xxxxx    {arg.Kind}: {FormatTypedConstant(arg)}");
                //        }
                //    }
                //    else
                //    {
                //        sb.AppendLine($"//  +++++++ No constructor arguments");
                //    }



                //    foreach (var prop in attr.NamedArguments)
                //    {
                //        sb.AppendLine($"//  +++++++ Property: {prop.Key} - {FormatTypedConstant(prop.Value)} - {prop.Value.Type?.Name}");
                //    }
                //}
                ////if (attributes.Length > 0)
                ////{
                ////    sb.AppendLine($"// Attributes:");
                ////    foreach (var attr in attributes)
                ////    {
                ////        sb.AppendLine($"// -------  [{attr.AttributeClass?.ToDisplayString()}]");
                ////    }
                ////}

                ////bool hasJsonAttr = HasAttribute(symbol, "JsonSerializableAttribute");

                //sb.AppendLine($"// Class Name: {className}");
                //sb.AppendLine($"// Class Namespace: {classNamespace}");
                //sb.AppendLine($"// Class Name with Namespace: {classNameWithNamespace}");

                //int? value = GetAttributeValue<int>(symbol, "WebServiceClient.Attributes.ModelAttribute", "Value");
                //string? access = GetAttributeValue<string>(symbol, "WebServiceClient.Attributes.ModelAttribute", "Access");
                //string? name = GetAttributeValue<string>(symbol, "WebServiceClient.Attributes.ModelAttribute", "Name");

                //sb.AppendLine($"// WebServiceClient.Attributes.ModelAttribute - Value: {value}");
                //sb.AppendLine($"// WebServiceClient.Attributes.ModelAttribute - Access: {access}");
                //sb.AppendLine($"// WebServiceClient.Attributes.ModelAttribute - Name: {name}");

                sb.AppendLine($"public partial class {className}");
                sb.AppendLine("{");
                sb.AppendLine("}");

                sb.AppendLine();
            }

            //string names = string.Join(",\n     ", nameList);
            //var theCode = $$"""   
            //namespace 111;

            //public static class ClassNames
            //{
            //    {{names}}
            //}
            //""";
            context.AddSource("ClassNames.g.cs", sb.ToString());
        }

        private INamedTypeSymbol? GetSymbol(Compilation compilation, ClassDeclarationSyntax syntax)
        {
            return compilation.GetSemanticModel(syntax.SyntaxTree).GetDeclaredSymbol(syntax) as INamedTypeSymbol;
        }

        private bool HasAttributeWithName(INamedTypeSymbol symbol, string attributeName)
        {
            return symbol.GetAttributes().Any(attr => attr.AttributeClass?.Name == attributeName || attr.AttributeClass?.Name == attributeName + "Attribute");
        }

        private bool HasAttributeWithNameAndNamespace(INamedTypeSymbol symbol, string attributeNameWithNamespace)
        {
            return symbol.GetAttributes().Any(attr => attr.AttributeClass?.ToDisplayString() == attributeNameWithNamespace || attr.AttributeClass?.ToDisplayString() == attributeNameWithNamespace + "Attribute");
        }

        private bool HasAttributeWithName(Compilation compilation, ClassDeclarationSyntax syntax, string attributeName)
        {
            var symbol = compilation.GetSemanticModel(syntax.SyntaxTree).GetDeclaredSymbol(syntax) as INamedTypeSymbol;

            return symbol!.GetAttributes().Any(attr => attr.AttributeClass?.Name == attributeName || attr.AttributeClass?.Name == attributeName + "Attribute");
        }

        private bool HasAttributeWithNameAndNamespace(Compilation compilation, ClassDeclarationSyntax syntax, string attributeNameWithNamespace)
        {
            var symbol = compilation.GetSemanticModel(syntax.SyntaxTree).GetDeclaredSymbol(syntax) as INamedTypeSymbol;

            return symbol!.GetAttributes().Any(attr => attr.AttributeClass?.ToDisplayString() == attributeNameWithNamespace || attr.AttributeClass?.ToDisplayString() == attributeNameWithNamespace + "Attribute");
        }

        private T? GetAttributeValue<T>(INamedTypeSymbol symbol, string attributeNameWithNamespace, string propertyName)
        {
            var attribute = symbol.GetAttributes().SingleOrDefault(a => a.AttributeClass?.ToDisplayString() == attributeNameWithNamespace || a.AttributeClass?.ToDisplayString() == attributeNameWithNamespace + "Attribute");

            if (attribute == null)
                return default;

            // Find the named argument with the specified property name
            foreach (var pair in attribute.NamedArguments)
            {
                if (pair.Key == propertyName)
                {
                    var typedConstant = pair.Value;
                    if (typedConstant.Value is T tValue)
                        return tValue;

                    // Try to convert if possible
                    try
                    {
                        if (typedConstant.Value != null)
                            return (T)Convert.ChangeType(typedConstant.Value, typeof(T));
                    }
                    catch
                    {
                        // Ignore conversion errors and return default
                    }
                    return default;
                }
            }
            return default;
        }

        private string FormatTypedConstant(TypedConstant constant)
        {
            if (constant.IsNull)
            {
                return "null";
            }
            if (constant.Kind == TypedConstantKind.Array)
            {
                var values = constant.Values.Select(FormatTypedConstant);
                return $"[{string.Join(", ", values)}]";
            }
            if (constant.Type?.TypeKind == TypeKind.Enum)
            {
                var enumType = constant.Type;
                var value = constant.Value;
                if (value != null)
                {
                    var member = enumType.GetMembers()
                        .OfType<IFieldSymbol>()
                        .FirstOrDefault(f => f.HasConstantValue && Equals(f.ConstantValue, value));
                    if (member != null)
                        return $"{enumType.Name}.{member.Name}";
                }
                return $"{enumType.Name}.{value}";
            }
            if (constant.Type?.SpecialType == SpecialType.System_String)
            {
                return $"\"{constant.Value}\"";
            }
            return constant.Value?.ToString() ?? "null";
        }

        private void DebugClass(StringBuilder sb, INamedTypeSymbol symbol)
        {
            var classNamespace = symbol!.ContainingNamespace?.ToDisplayString();
            var classNameWithNamespace = symbol.ToDisplayString();
            var className = symbol.Name;

            sb.AppendLine();
            sb.AppendLine($"// Class Name: {className}");
            sb.AppendLine($"// Class Namespace: {classNamespace}");
            sb.AppendLine($"// Class Name with Namespace: {classNameWithNamespace}");
            sb.AppendLine();

        }

        private void DebugProperties(StringBuilder sb, INamedTypeSymbol symbol)
        {
            sb.AppendLine();

            foreach (var prop in symbol.GetMembers().OfType<IPropertySymbol>())
            {
                
                sb.AppendLine($"// Property: {prop.Type.ToDisplayString()} {prop.Name} {{ {(prop.GetMethod != null ? "get; " : "")}{(prop.SetMethod != null ? "set;" : "")} }}");


            }
            sb.AppendLine();
        }


        private void DebugAttributes(StringBuilder sb, INamedTypeSymbol symbol)
        {
            sb.AppendLine();
            foreach (var attr in symbol.GetAttributes())
            {
                var attrName = attr.AttributeClass?.Name;
                var attrNamespace = attr.AttributeClass?.ContainingNamespace?.ToDisplayString();
                var attrFullName = attr.AttributeClass?.ToDisplayString();

                sb.AppendLine($"// Attribute: {attrName} - {attrNamespace} - {attrFullName}");

                if (attr.ConstructorArguments.Length > 0)
                {
                    sb.AppendLine($"// Has constructor arguments");
                    foreach (var arg in attr.ConstructorArguments)
                    {
                        sb.AppendLine($"//     {FormatTypedConstant(arg)} - {arg.Kind} ");
                    }
                }
                else
                {
                    sb.AppendLine($"// No constructor arguments");
                }

                if (attr.NamedArguments.Length > 0)
                {
                    sb.AppendLine($"// Has named arguments");

                    foreach (var prop in attr.NamedArguments)
                    {
                        sb.AppendLine($"//      {prop.Key} - {FormatTypedConstant(prop.Value)} - {prop.Value.Type?.Name}");
                    }
                }
                else
                {
                    sb.AppendLine($"// No named arguments");
                }
            }
            sb.AppendLine();
        }

        private void Debug(StringBuilder sb, (Compilation Left, ImmutableArray<ClassDeclarationSyntax> Right) tuple)
        {
            sb.AppendLine("//##############################################################");

 //         foreach (var cl in Class.GetAllClasses(tuple))

            foreach (var cl in Class.GetAllClassesWithAttribute(tuple, "WebServiceClient.Attributes.ModelAttribute"))
            {
                sb.AppendLine();
                sb.AppendLine($"// Class: {cl.NameSpace} - {cl.Name} - {cl.NameWithNameSpace}");

                foreach (var prop in cl.Properties)
                {
                    sb.AppendLine($"//   Property: {prop.TypeName} {prop.Name} {{ {(prop.HasGet ? "get; " : "")}{(prop.HasSet ? "set;" : "")} }}");
                }

                foreach (var attr in cl.Attributes)
                {
                    sb.AppendLine($"//   Attribute: {attr.Name} - {attr.NameSpace} - {attr.NameWithNameSpace}");

                    foreach (var arg in attr.ConstructorArguments)
                    {
                        sb.AppendLine($"//      {arg}");
                    }
                    foreach (var arg in attr.NamedArguments)
                    {
                        sb.AppendLine($"//      {arg}");
                    }
                }
            }
            sb.AppendLine();
            sb.AppendLine("//##############################################################");
        }
    }
}
